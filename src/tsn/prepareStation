-- To avoid dealing with namespaces and imported scripts not
-- being able to access local variables, I've decided to inject
-- the source code when it's loaded on the filesystem.
--INJECT/turtleUtils


-- START OF LOCAL SCRIPT
local args={...};
local radius = args[1] or 5;
local height = args[2] or 5;

function dropoffAndRestock(configuration, ignoreBlocks, restockIgnore, dropTorches, dropIgnore)
    dropoff(configuration, ignoreBlocks, dropTorches, dropIgnore)
    restock(configuration, ignoreBlocks, restockIgnore)
end


-- EMPTIES THE INVENTORY
function dropoff(configuration, ignoreBlocks, dropTorches, dropIgnore)
    -- DROP THE TORCHES
    turtle.select(1)
    local torchSlot=0
    if configuration.placeTorches then
        turtleUtils.torchSlot=1
        if dropTorches then
            api_turtleExt.drop(configuration.torchSuckDir)
        end
    end
    -- DROP THE EXTRAS OF THE IGNORE BLOCKS
    api_turtleExt.turnTo(configuration.itemDropDir)
    for i=1+turtleUtils.torchSlot,turtleUtils.torchSlot+ignoreBlocks do
        turtle.select(i)
        api_turtleExt.drop(api_turtleExt.turnedDir(configuration.itemDropDir), math.max(turtle.getItemCount(i)-1, 0))
    end
    -- DROP THE OTHER ITEMS
    for i=turtleUtils.torchSlot+ignoreBlocks+1,16 do
        turtle.select(i)
        api_turtleExt.drop(api_turtleExt.turnedDir(configuration.itemDropDir), turtle.getItemCount(i))
    end
    api_turtleExt.turnFrom(configuration.itemDropDir)
    turtle.select(1)
    -- DROP THE IGNORE BLOCKS
    if dropIgnore then
        api_turtleExt.turnTo(configuration.ignoreDir)
        for i=1+turtleUtils.torchSlot,turtleUtils.torchSlot+ignoreBlocks do
            turtle.select(i)
            api_turtleExt.drop(api_turtleExt.turnedDir(configuration.ignoreDir), 1)
        end
        api_turtleExt.turnFrom(configuration.ignoreDir)
    end
end


-- RESTOCKS THE TORCHES
function restockTorches(configuration)
    turtle.select(1)
    local dispMsg=true
    local firstEmpty=2
    -- CALCULATE THE FIRST EMPTY SLOT
    while ((turtle.getItemCount(firstEmpty)>0) and (firstEmpty<16)) do
        firstEmpty = firstEmpty+1
    end
    -- ALIGN WITH THE TORCH CHEST AND SUCK A STACK
    api_turtleExt.turnTo(configuration.torchSuckDir)
    local tDir=api_turtleExt.turnedDir(configuration.torchSuckDir)
    while turtle.getItemCount(firstEmpty)==0 do
        if not api_turtleExt.suck(tDir) then
            if dispMsg then
                term.clear()
                term.setCursorPos(1,1)
                print("---------------------------------")
                print("Please place some torches in a chest")
                print("Chest Direction:  "..configuration.torchSuckDir)
                print("Torches Required: "..(turtle.getItemSpace(1)+1))
                print("---------------------------------")
                dispMsg=false
            end
        else
            dispMsg=true
        end
        sleep(0)
    end
    term.clear()
    -- CHECK IF THERE ARE ACTUALLY TORCHES IN SLOT 1 AND DUMP ANY EXCESS TORCHES
    if turtle.compareTo(firstEmpty) then
        turtle.select(firstEmpty)
        api_turtleExt.drop(tDir)
        api_turtleExt.turnFrom(configuration.torchSuckDir)
    else
        turtle.select(firstEmpty)
        api_turtleExt.drop(tDir)
        turtle.select(1)
        api_turtleExt.turnFrom(configuration.torchSuckDir)
        api_turtleExt.drop(configuration.itemDropDir)
        restockTorches(configuration)
    end
    turtle.select(1)
end


-- RESTOCKS THE INVENTORY
function restock(configuration, ignoreBlocks, restockIgnore)
    turtle.select(1)
    local torchSlot=0
    -- RESTOCK THE TORCHES
    if configuration.placeTorches then
        turtleUtils.torchSlot=1
        restockTorches(configuration)
    end
    -- RESTOCK THE IGNORE BLOCKS
    if restockIgnore then
        api_turtleExt.turnTo(configuration.ignoreDir)
        local tDir=api_turtleExt.turnedDir(configuration.ignoreDir)
        for i=1+turtleUtils.torchSlot,ignoreBlocks+turtleUtils.torchSlot do
            turtle.select(i)
            api_turtleExt.suck(tDir)
        end
        api_turtleExt.turnFrom(configuration.ignoreDir)
    end
    turtle.select(1)
end

local function waitForInventoryToArriveInChest()
    --detect chest turtleUtils.up
    --drop off excess inv
    --wait until desired inv is present then take
end;

local function prepareStation()
    turtleUtils.turn(turtleUtils.right);
    turtleUtils.moveWithDig(turtleUtils.forward);
    turtleUtils.moveWithDig(turtleUtils.up, 2); -- destroy redstone signal powering woodenpipe, then one wire
    turtleUtils.turn(turtleUtils.right, 2);
    turtleUtils.dig(turtleUtils.forward); -- destroy woodenpipe
    turtleUtils.place(turtleUtils.forward, turtleUtils.stonePipe1Slot);
    turtleUtils.move(turtleUtils.down);
    turtleUtils.place(turtleUtils.up, turtleUtils.stonePipe1Slot); -- plenum
    turtleUtils.move(turtleUtils.down);
    turtleUtils.place(turtleUtils.up, turtleUtils.stonePipe1Slot); -- in ceiling
    turtleUtils.move(turtleUtils.down);
    turtleUtils.place(turtleUtils.up, turtleUtils.stonePipe1Slot); -- in ceiling
    turtleUtils.move(turtleUtils.forward);
    turtleUtils.dig(turtleUtils.up);
    turtleUtils.place(turtleUtils.up, turtleUtils.stonePipe1Slot);
    turtleUtils.move(turtleUtils.down);
    turtleUtils.place(turtleUtils.up, turtleUtils.stonePipe1Slot);
    turtleUtils.move(turtleUtils.down);
    turtleUtils.place(turtleUtils.up, turtleUtils.stonePipe1Slot);
    turtleUtils.dig(turtleUtils.down);
    turtleUtils.place(turtleUtils.down, turtleUtils.stonePipe1Slot);
    turtleUtils.move(turtleUtils.back);
    turtleUtils.place(turtleUtils.forward, turtleUtils.stonePipe1Slot);
    turtleUtils.dig(turtleUtils.down);
    turtleUtils.place(turtleUtils.down, turtleUtils.stonePipe1Slot);
    turtleUtils.move(turtleUtils.back);
    turtleUtils.place(turtleUtils.down, turtleUtils.stonePipe1Slot);
    turtleUtils.move(turtleUtils.back);
    turtleUtils.place(turtleUtils.down, turtleUtils.stonePipe1Slot);
    turtleUtils.move(turtleUtils.back);
    turtleUtils.place(turtleUtils.down, turtleUtils.woodenPipeSlot);
    turtleUtils.turn(turtleUtils.right, 2);
    turtleUtils.moveWithDig(turtleUtils.forward);
    turtleUtils.dig(turtleUtils.down);
    turtleUtils.place(turtleUtils.down, turtleUtils.smallChestSlot);
    turtleUtils.turn(turtleUtils.left);
    turtleUtils.dig(turtleUtils.forward);
    turtleUtils.place(turtleUtils.forward, turtleUtils.smallChestSlot);
    turtleUtils.dig(turtleUtils.up);
    turtleUtils.place(turtleUtils.up, turtleUtils.smallChestSlot);
    turtleUtils.turn(turtleUtils.right, 2);
    turtleUtils.moveWithDig(turtleUtils.forward);
    turtleUtils.turn(turtleUtils.left);
    --IF PLACING THE TORCH ON CHEST DOESN'T WORK THEN
    turtleUtils.dig(turtleUtils.down);
    turtleUtils.place(turtleUtils.down, turtleUtils.redstoneTorchSlot);
    --IF PLACING THE TORCH ON CHEST DOESN'T WORK THEN
    turtleUtils.move(turtleUtils.back);
    turtleUtils.place(turtleUtils.forward, turtleUtils.smallChestSlot);
    turtleUtils.dig(turtleUtils.down);
    turtleUtils.place(turtleUtils.down, turtleUtils.redstoneEngineSlot);
    turtleUtils.place(turtleUtils.forward, turtleUtils.redstoneTorchSlot);
end;

local function moveToStartingPosition(radius)
    local radius = radius;
    turtleUtils.log (fine, "Entering moveToStartingPosition()");
    currentLogIndent = currentLogIndent + 1;
    turtleUtils.turn(turtleUtils.left);
    turtleUtils.move(radius - 1);
    turtleUtils.turn(turtleUtils.left);
    turtleUtils.move(radius - 1);
    turtleUtils.moveWithDig(turtleUtils.up);
    currentLogIndent = currentLogIndent - 1;
    turtleUtils.log (fine, "Exiting moveToStartingPositionForWalls()");
end

if ((radius == nil or radius=="") or (height == nil or height=="")) then
    fs.delete(turtleUtils.logFileName);
    print ("What is the radius of the station? (5 is normal)");
    radius = io.read();
    radius = tonumber(radius);

    print ("What is the height, including floor and ceiling layers, of the station? (5 is normal)");
    height = io.read();
    height = tonumber(height);
end;

moveToStartingPosition(radius);
waitForInventoryToArriveInChest();
prepareStation();
