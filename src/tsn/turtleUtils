up = "up";
down = "down";
forward = "forward";
right = "right";
left = "left";
back = "back";
northFacing = 0;
eastFacing = 90;
southFacing = 180;
westFacing = 270;
rightFacing = 90;
leftFacing = -90;
forwardMoving = 1;
backwardsMoving = -1;
upMoving = 1;
downMoving = -1;
noMoving = 0;

success = true;
failure = false;

blockAlreadyPresent = 1;
notEnoughInventory = 2;

error = 0;
coarse = 1;
fine = 2;
debug = 3;
fineDebug = 4;

FUEL_SLOT = 16;
currentSlotNum = 1;

logFileName = os.getComputerLabel()..".log";
xyzFileName = os.getComputerLabel().."-xyz.txt";

currentLogLevel = debug;
currentLogIndent = 0;

currentX = 0;
currentY = 0;
currentZ = 0;
currentFacing = 0;

lightThreshold = 6;
lastLightX = 0;
lastLightY = 0;
lastLightZ = 0;

function log(logLevel, line, currentLogIndent)
    local currentLogIndent = currentLogIndent or 0;
    local logLevel = logLevel or coarse;
    if (logLevel <= currentLogLevel) then
        local entry = string.format("%.2f", os.clock()).."\t - ";
        for i=1,currentLogIndent do
            entry = entry.."  ";
        end;
        entry = entry..line;
        local filename = logFileName;
        local file = fs.open(filename, "a"); -- "w" opens the file, erasing all existing contents
        file.writeLine(entry);
        file.close();
    end;
end;

function writeXYZ()
    local file = fs.open(xyzFileName, "w"); -- "w" opens the file, erasing all existing contents
    file.writeLine(currentX);
    file.writeLine(currentY);
    file.writeLine(currentZ);
    file.writeLine(currentFacing);
    file.close();
end;

function updateXY(xy)
    if (currentFacing == northFacing) then
        currentY = currentY + xy;
    elseif (currentFacing == southFacing) then
        currentY = currentY - xy;
    elseif (currentFacing == eastFacing) then
        currentX = currentX + xy;
    elseif (currentFacing == westFacing) then
        currentX = currentX - xy;
    end;
    writeXYZ();
end;

function updateZ(z)
    currentZ = currentZ + z;
    writeXYZ();
end;

function updateFacing(degrees)
    currentFacing = currentFacing + degrees;
    if (currentFacing >= 360) then
        currentFacing = currentFacing - 360;
    elseif (currentFacing <= -360) then
        currentFacing = currentFacing + 360;
    end;
    writeXYZ();
end;

function readXYZ()
    local file = fs.open(xyzFileName, "r"); -- "r" opens the file for reading
    if (file == nil) then
        file.close();
        writeXYZ();
        return;
    end;
    currentX = file.readLine();
    currentY = file.readLine();
    currentZ = file.readLine();
    currentFacing = file.readLine();
    file.close();
end;

function turn(turnDirection, repeatCount)
    local repeatCount = repeatCount or 1;

    for i = 1,repeatCount do
        if (turnDirection == left) then
            if (turtle.turnLeft()) then updateFacing(leftFacing); log(fine, "turned: left", currentLogIndent); else log(debug, "failed to turn: left", currentLogIndent); return failure;  end;
        elseif (turnDirection == right) then
            if (turtle.turnRight()) then updateFacing(rightFacing); log(fine, "turned: right", currentLogIndent); else log(debug, "failed to turn: right", currentLogIndent); return failure;  end;
        end;
    end;

    return success;
end;

function move(moveDirection)
    local moveDirection = moveDirection or forward;

    if (moveDirection == forward) then
        if (turtle.forward()) then updateXY(forwardMoving); log(fine, "moved: forward", currentLogIndent); return success;  else log(debug, "failed to move: forward", currentLogIndent); return failure;  end;
    elseif (moveDirection == back) then
        if (turtle.back()) then updateXY(backwardsMoving); log(fine, "moved: back", currentLogIndent); return success;  else log(debug, "failed to move: back", currentLogIndent); return failure;  end;
    elseif (moveDirection == up) then
        if (turtle.up()) then updateZ(upMoving); log(fine, "moved: up", currentLogIndent); return success;  else log(debug, "failed to move: up", currentLogIndent); return failure;  end;
    elseif (moveDirection == down) then
        if (turtle.down()) then updateZ(downMoving); log(fine, "moved: down", currentLogIndent); return success;  else log(debug, "failed to move: down", currentLogIndent); return failure;  end;
    end;
end;

function dig(digDirection)
    local digDirection = digDirection or forward;

    if (digDirection == forward) then
        if (turtle.dig()) then log(fine, "dug: forward", currentLogIndent); return success; else log(debug, "failed to dig: forward", currentLogIndent); return failure; end;
    elseif (digDirection == up) then
        if (turtle.digUp()) then log(fine, "dug: up", currentLogIndent); return success;  else log(debug, "failed to dig: up", currentLogIndent); return failure;  end;
    elseif (digDirection == down) then
        if (turtle.digDown()) then log(fine, "dug: down", currentLogIndent); return success;  else log(debug, "failed to dig: down", currentLogIndent); return failure;  end;
    end;
end;

function detect(detectDirection)
    local detectDirection = detectDirection or forward;

    if (detectDirection == forward) then
        if (turtle.detect()) then log(fine, "detected: item exists forward", currentLogIndent); return success; else log(debug, "detected: no item exists forward", currentLogIndent); return failure; end;
    elseif (detectDirection == up) then
        if (turtle.detectUp()) then log(fine, "detected: item exists up", currentLogIndent); return success;  else log(debug, "detected: no item exists up", currentLogIndent); return failure;  end;
    elseif (detectDirection == down) then
        if (turtle.detectDown()) then log(fine, "detected  item exists down", currentLogIndent); return success;  else log(debug, "detected: no item exists down", currentLogIndent); return failure;  end;
    end;
end;

function compare(direction)
    local direction = direction or forward;

    if (direction == forward) then
        if (turtle.compare()) then log(fine, "compared: forward item same as slot ("..currentSlotNum..")", currentLogIndent); return success; else log(debug, "compared: forward item not same as a slot ("..currentSlotNum..")", currentLogIndent); return failure; end;
    elseif (direction == up) then
        if (turtle.compareUp()) then log(fine, "compared: up item same as slot ("..currentSlotNum..")", currentLogIndent); return success;  else log(debug, "compared: up item not same as a slot ("..currentSlotNum..")", currentLogIndent); return failure;  end;
    elseif (direction == down) then
        if (turtle.compareDown()) then log(fine, "compared: down item same as slot ("..currentSlotNum..")", currentLogIndent); return success;  else log(debug, "compared: down item not same as a slot ("..currentSlotNum..")", currentLogIndent); return failure;  end;
    end;
end;

function attack(attackDirection)
    local attackDirection = attackDirection or forward;

    if (attackDirection == forward) then
        if (turtle.attack()) then log(fine, "attacked: forward", currentLogIndent); return success; else log(debug, "failed to atack: forward", currentLogIndent); return failure; end;
    elseif (attackDirection == up) then
        if (turtle.attackUp()) then log(fine, "attacked: up", currentLogIndent); return success;  else log(debug, "failed to attack: up", currentLogIndent); return failure;  end;
    elseif (attackDirection == down) then
        if (turtle.attackDown()) then log(fine, "attacked: down", currentLogIndent); return success;  else log(debug, "failed to attack: down", currentLogIndent); return failure;  end;
    end;
end;

function place(placeDirection)
    local placeDirection = placeDirection or forward;

    if (placeDirection == forward) then
        if (turtle.place()) then log(fine, "placed: forward", currentLogIndent); return success; else log(debug, "failed to place: forward", currentLogIndent); return failure; end;
    elseif (placeDirection == up) then
        if (turtle.placeUp()) then log(fine, "placed: up", currentLogIndent); return success;  else log(debug, "failed to place: up", currentLogIndent); return failure;  end;
    elseif (placeDirection == down) then
        if (turtle.placeDown()) then log(fine, "placed: down", currentLogIndent); return success;  else log(debug, "failed to place: down", currentLogIndent); return failure;  end;
    end;
end;

function select(slot)
    local slot = slot or currentSlotNum;
    log (fine, "Entering select("..slot..")", currentLogIndent);
    currentLogIndent = currentLogIndent + 1;

    local selectStatus = turtle.select(slot);
    if (selectStatus) then
        log(fine, "selected: "..slot, currentLogIndent);
        currentSlotNum = slot;  -- set the global slot value
    else
        log(fine, "failed to select: "..slot, currentLogIndent);
    end;
    if (currentLogLevel == debug) then
        currentLogIndent = currentLogIndent + 1;
        log(debug, "items remaining in slot "..slot..": "..tostring(turtle.getItemCount(slot)), currentLogIndent);
        currentLogIndent = currentLogIndent - 1;
    end;

    currentLogIndent = currentLogIndent - 1;
    log (fine, "Exiting select()", currentLogIndent);
    return selectStatus;
end;

function selectItem(slot, isOverflow)
    local slot = slot or currentSlotNum;
    local isOverflow = isOverflow or false;
    log (fine, "Entering selectItem("..slot..","..tostring(isOverflow)..")", currentLogIndent);
    currentLogIndent = currentLogIndent + 1;

    local isSuccess = select(slot);
    if (isOverflow) then
        if (isSuccess) then
            if (turtle.getItemCount(slot) > 1) then
                currentLogIndent = currentLogIndent - 1;
                log (fine, "Exiting selectItem()", currentLogIndent);
                return isSuccess;
            else
                for i = 1,16 do
                    if (i ~= slot and turtle.compareTo(i) and turtle.getItemCount(i) > 1 and select(i)) then
                        if (turtle.transferTo(slot, turtle.getItemCount(i) - 1) and select(slot)) then
                            log(debug, "Ran down to 1 resource in slot "..slot..". Using items from slot "..i.." to compensate.", currentLogIndent);
                            currentLogIndent = currentLogIndent - 1;
                            log (fine, "Exiting selectItem()", currentLogIndent);
                            return isSuccess;
                        end;
                    end;
                end;
                log (fine, "Overflow requested, but no remaining items exist in inventory. Using last item from slot ("..slot..").");
                currentLogIndent = currentLogIndent - 1;
                log (fine, "Exiting selectItem()", currentLogIndent);
                return isSuccess;
            end;
        else
            log(error, "    Critical Error: No items found in slot ("..slot..") with which to compare against in order to perform overflow selection. Stopping operation.");
            currentLogIndent = currentLogIndent - 1;
            log (fine, "Exiting selectItem()", currentLogIndent);
            shell.exit();
        end;
    else
        currentLogIndent = currentLogIndent - 1;
        log (fine, "Exiting selectItem()", currentLogIndent);
        return isSuccess;
    end;

end

function placeItem(placeDirection, slot, isOverflow, isCompare, isDetect, isAnchorProtection)
    local placeDirection = placeDirection or forward;
    local slot = slot or currentSlotNum;
    local isOverflow = isOverflow or false;
    local isDetect = isDetect or false;
    local isCompare = isCompare or false;
    local isAnchorProtection = isAnchorProtection or false;
    log (fine, "Entering placeItem("..placeDirection..", "..slot..", "..tostring(isOverflow)..", "..tostring(isCompare)..", "..tostring(isDetect)..", "..tostring(isAnchorProtection)..")", currentLogIndent);
    currentLogIndent = currentLogIndent + 1;

    if (isDetect and detect(placeDirection)) then
        currentLogIndent = currentLogIndent - 1;
        log (fine, "Exiting placeItem()", currentLogIndent);
        return success;
    end;

    if (not selectItem(slot, isOverflow)) then
        currentLogIndent = currentLogIndent - 1;
        log (fine, "Exiting placeItem()", currentLogIndent);
        return notEnoughInventory;
    end;

    if (isCompare) then
        if (compare(placeDirection)) then
            currentLogIndent = currentLogIndent - 1;
            log (fine, "Exiting placeItem()", currentLogIndent);
            return success;
        else
            while (detect(placeDirection)) do
                dig(placeDirection);
            end;
        end;
    end;

    if (place(placeDirection)) then
        currentLogIndent = currentLogIndent - 1;
        log (fine, "Exiting placeItem()", currentLogIndent);
        return success;
    elseif (isAnchorProtection) then
        log(fine, "Moving forward in an attempt to find an anchor block.", currentLogIndent);
        move(direction);
        local placeStatus = placeItem(placeDirection, slot, isOverflow, false, false, true);
        log(fine, "Moving backward after finding an anchor block.", currentLogIndent);
        move(getOppositeDirection(placeDirection));
        currentLogIndent = currentLogIndent - 1;
        log (fine, "Exiting placeItem()", currentLogIndent);
        return placeStatus;
    else
        log(fine, "Failed: A block is already present at location ("..placeDirection..").", currentLogIndent);
        currentLogIndent = currentLogIndent - 1;
        log (fine, "Exiting placeItem()", currentLogIndent);
        return blockAlreadyPresent;
    end;
end;

function moveWithDig(direction, steps, attempts)
    local direction = direction or forward;
    local steps = steps or 1
    local attempts = attempts or 10
    log (fine, "Entering moveWithDig("..direction..","..steps..","..attempts..")", currentLogIndent);
    currentLogIndent = currentLogIndent + 1;

    for i = 1,steps do
        local tries = 1;
        while (not move(direction) and ((attempts == 0) or (tries <= attempts))) do
            dig(direction);
            -- THIS CONSTRUCTION IS USED SO TRIES WON'T OVERFLOW WHEN ATTEMPTS==0
            tries = math.min(tries + 1, attempts + 1)
            sleep(0)
        end;
    end;
    currentLogIndent = currentLogIndent - 1;
    log (fine, "Exiting moveWithDig()", currentLogIndent);
end;

function distanceBetweenTwoPoints(x1, y1, z1, x2, y2, z2)
    local xDistance = x2 - x1;  --horizontal difference
    local yDistance = y2 - y1;  --vertical difference
    local zDistance = z2 - z1;  --outward difference
    local dist = math.sqrt( (xDistance*xDistance) + (yDistance*yDistance) + (zDistance*zDistance) );    -- distance using Pythagoras theorem
    return dist;
end;

function getOppositeDirection(currentDirection)
    local currentDirection = currentDirection;
    if (currentDirection == up) then return down; end;
    if (currentDirection == down) then return up; end;
    if (currentDirection == left) then return right; end;
    if (currentDirection == right) then return left; end;
    if (currentDirection == forward) then return back; end;
    if (currentDirection == back) then return forward; end;
end;

function placeLight(lightSlot)
    log (fine, "Entering placeLight("..lightSlot..")", currentLogIndent);
    currentLogIndent = currentLogIndent + 1;
    if ((distanceBetweenTwoPoints(currentX, currentY, currentZ, lastLightX, lastLightY, lastLightZ) >= lightThreshold) and (placeItem(up, lightSlot, true))) then
        lastLightX = currentX;
        lastLightY = currentY;
        lastLightZ = currentZ;
        log (fine, "Placed light", currentLogIndent);
    end;
    currentLogIndent = currentLogIndent - 1;
    log (fine, "Exiting placeLight()", currentLogIndent);
end;

function refuel(fuelSlot, amount, threshold)
    local fuelSlot = fuelSlot or FUEL_SLOT;
    local amount = amount or 1;
    local threshold = threshold or 5;
    if turtle.getFuelLevel() <= threshold then
        select(fuelSlot);
        turtle.refuel(amount);
    end;
end;

readXYZ();