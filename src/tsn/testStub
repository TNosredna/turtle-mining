-- Must allow for 1 available block above ceiling and 1 available block below floor

local upTick = 0;
local downTick = 1;
local leftTick = 0;
local rightTick = 1;
local forwardTick = 0;
local backTick = 1;

local wallFiller1Pos = 1;
local wallFiller2Pos = 2;
local wallFiller3Pos = 3;
local floorFillerPos = 4;
local roofFillerPos = 5;
local skylightFillerPos = 6;

local up = "up";
local down = "down";
local forward = "forward";
local right = "right";
local left = "left";
local back = "back";

local error = 0;
local coarse = 1;
local fine = 2;
local debug = 3;
local currentLogLevel = debug;

local currentSlotNum = 1;

local success = true;
local failure = false;
local blockPlaced = 0;
local blockAlreadyPresent = 1;
local notEnoughInventory = 2;

local criticalError = false;

local function log(logLevel, line)
    local logLevel = logLevel or coarse;
    if (logLevel <= currentLogLevel) then
        local line = line;
        local filename = os.computerID()..".log";
        local file = fs.open(filename, "a"); -- "w" opens the file, erasing all existing contents
        file.writeLine(os.time().." ["..logLevel.."] - "..line);
        file.close();
    end;
end

local function turn(turnDirection)
    local turnDirection = turnDirection;

    if (turnDirection == left) then
        if (turtle.turnLeft()) then log(fine, "turned: left"); return success;  else log(debug, "failed to turn: left"); return failure;  end;
    elseif (turnDirection == right) then
        if (turtle.turnRight()) then log(fine, "turned: right"); return success;  else log(debug, "failed to turn: right"); return failure;  end;
    end;
end;

local function move(moveDirection)
    local moveDirection = moveDirection or forward;

    if (moveDirection == forward) then
        if (turtle.forward()) then log(fine, "moved: forward"); return success;  else log(debug, "failed to move: forward"); return failure;  end;
    elseif (moveDirection == back) then
        if (turtle.back()) then log(fine, "moved: back"); return success;  else log(debug, "failed to move: back"); return failure;  end;
    elseif (moveDirection == up) then
        if (turtle.up()) then log(fine, "moved: up"); return success;  else log(debug, "failed to move: up"); return failure;  end;
    elseif (moveDirection == down) then
        if (turtle.down()) then log(fine, "moved: down"); return success;  else log(debug, "failed to move: down"); return failure;  end;
    end;
end;

local function dig(digDirection)
    local digDirection = digDirection or forward;

    if (digDirection == forward) then
        if (turtle.dig()) then log(fine, "dug: forward"); return success; else log(debug, "failed to dig: forward"); return failure; end;
    elseif (digDirection == up) then
        if (turtle.digUp()) then log(fine, "dug: up"); return success;  else log(debug, "failed to dig: up"); return failure;  end;
    elseif (digDirection == down) then
        if (turtle.digDown()) then log(fine, "dug: down"); return success;  else log(debug, "failed to dig: down"); return failure;  end;
    end;
end;

local function select(slot)
    local slot = slot;

    turtle.select(slot);
    log(fine, "selected: "..slot);
    currentSlotNum = slot;
    if (currentLogLevel == debug) then
        log(debug, "    items left in slot "..slot..": "..tostring(turtle.getItemCount(slot)));
    end;
end;

-- returns 0 on success, 1 on block already present, and 2 on not enough inventory in slot
local function place(placeDirection)
    local placeDirection = placeDirection or forward;
    local slot = currentSlotNum;
    local actionFailed = false;

    if (placeDirection == forward) then
        if (turtle.place()) then
            log(fine, "placed: forward");
        else
            actionFailed = true;
            log(debug, "failed to place: forward");
        end;
    elseif (placeDirection == up) then
        if (turtle.placeUp()) then
            log(fine, "placed: up");
        else
            actionFailed = true;
            log(debug, "failed to place: up");
        end;
    elseif (placeDirection == down) then
        if (turtle.placeDown()) then
            log(fine, "placed: down");
        else
            actionFailed = true;
            log(debug, "failed to place: down");
        end;
    end;
    if (currentLogLevel == debug and actionFailed) then
        if (turtle.getItemCount(slot) > 0) then
            log(debug, "    a block is already present at target location");
            return blockAlreadyPresent;
        else
            log(debug, "    no items left in slot "..slot.." to place");
            return notEnoughInventory;
        end;
    end;
    return blockPlaced;
end;

-- look in slots 1-12 if selected slot if empty
local function selectWithOverflow(slot, attempts)
    local attempts = attempts or 10
    local slot = slot;

    select(slot)
    if turtle.getItemCount(slot) == 1 then
        select(1)
        local tries = 1
        while (not turtle.compareTo(slot) and ((attempts == 0) or (tries <= attempts))) do
            for i = 1,12 do
                select(i);
                if (turtle.compareTo(slot)) then
                    log(debug, "Ran down to 1 resource in slot "..slot.." stealing from slot "..i.." to compensate");
                    break;
                end;
            end
            -- THIS CONSTRUCTION IS USED SO TRIES WON'T OVERFLOW WHEN ATTEMPTS==0
            tries = math.min(tries + 1, attempts + 1)
        end
    end
end

-- dig if can't move
local function moveWithDig(direction, steps, attempts)
    log (fine, "Entering moveWithDig("..direction..")");
    local steps = steps or 1
    local attempts = attempts or 10
    local direction = direction;

    for i = 1,steps do
        local tries = 1;
        while (not move(direction) and ((attempts == 0) or (tries <= attempts))) do
            dig(direction);
            -- THIS CONSTRUCTION IS USED SO TRIES WON'T OVERFLOW WHEN ATTEMPTS==0
            tries = math.min(tries + 1, attempts + 1)
            sleep(0)
        end
    end
    log (fine, "Exiting moveWithDig()");
end

local function getOppositeDirection(currentDirection)
    local currentDirection = currentDirection;
    if (currentDirection == up) then return down; end;
    if (currentDirection == down) then return up; end;
    if (currentDirection == left) then return right; end;
    if (currentDirection == right) then return left; end;
    if (currentDirection == forward) then return back; end;
    if (currentDirection == back) then return forward; end;
end

-- move if can't replace. empty anchor protection
local function replace(direction, slot, attempts)
    log (fine, "Entering replace()");
    local moveBackCounter = 0;
    local attempts = attempts or 10;
    local tries = 1;
    local direction = direction;
    local slot = slot;

    selectWithOverflow(slot);
    local successCode = place(direction);
    while (not successCode == 0 and ((attempts==0) or (tries<=attempts))) do
        if (successCode==blockAlreadyPresent) then
            dig(direction);
        elseif (successCode==notEnoughInventory) then
            criticalError = true;
            break;
        else
            move(direction);
            moveBackCounter = moveBackCounter + 1;
        end
        successCode = place(direction);
        -- THIS CONSTRUCTION IS USED SO TRIES WON'T OVERFLOW WHEN ATTEMPTS==0
        tries = math.min(tries+1, attempts+1);
        sleep(0);
    end
    for i = 1,moveBackCounter do
        move(getOppositeDirection(direction));
    end
    if (criticalError) then
        log(error, "Critical Error - Exiting program to avoid running amok!");
        log (fine, "Exiting replace()");
        shell.exit();
    end;
    log (fine, "Exiting replace()");
end

local function transitionOverAnd180Degrees(turnDirection, steps)
    log (fine, "Entering transitionOverAnd180Degrees()");
    local steps = steps or 1;
    local turnDirection = turnDirection;

    turn(turnDirection);
    moveWithDig(forward, steps);
    turn(turnDirection);
    log (fine, "Exiting transitionOverAnd180Degrees()");
end

local function floorAndCeilingColumn(currentUpDownDirection, numberBlocks)
    log (fine, "Entering floorAndCeilingColumn()");
    local numberBlocks = numberBlocks or 5;
    local currentUpDownDirection = currentUpDownDirection;
    local initialFillSlot;
    local endingFillSlot;

    if currentUpDownDirection == up then
        initialFillSlot = floorFillerPos;
        endingFillSlot = roofFillerPos;
    else
        initialFillSlot = roofFillerPos;
        endingFillSlot = floorFillerPos;
    end

    replace(getOppositeDirection(currentUpDownDirection), initialFillSlot);
    moveWithDig(currentUpDownDirection, numberBlocks-4);
    replace(currentUpDownDirection, endingFillSlot);

    log (fine, "Exiting floorAndCeilingColumn()");
    return currentUpDownDirection;
end

local function floorAndCeilingRow(currentDirection, numberColumns)
    log (fine, "Entering floorAndCeilingRow()");
    local numberColumns = numberColumns or 9;
    local currentDirection = getOppositeDirection(currentDirection);

    for i = 1,numberColumns do
        currentDirection = floorAndCeilingColumn(getOppositeDirection(currentDirection));
        if (i < numberColumns) then
            moveWithDig(forward, 1)
        end
    end
    log (fine, "Exiting floorAndCeilingRow()");
    return currentDirection;
end

local function buildFloorAndCeiling(currentLeftRightDirection, currentUpDownDirection, numberRows)
    log (fine, "Entering buildFloorAndCeiling()");
    local numberRows = numberRows or 9;
    local numberColumns = numberRows;
    local currentUpDownDirection = getOppositeDirection(currentUpDownDirection);
    local currentLeftRightDirection = getOppositeDirection(currentLeftRightDirection);

    for i = 1,numberRows do
        currentUpDownDirection = floorAndCeilingRow(getOppositeDirection(currentUpDownDirection), numberColumns);
        if (i < numberRows) then
            currentLeftRightDirection = transitionOverAnd180Degrees(getOppositeDirection(currentLeftRightDirection));
        end
    end
    log (fine, "Exiting buildFloorAndCeiling()");
end

local function moveToStartingPositionForCeilingFloor(turnDirection)
    log (fine, "Entering moveToStartingPositionForWalls()");
    local turnDirection = turnDirection;
    transitionOverAnd180Degrees(turnDirection);
    moveWithDig(forward);
    log (fine, "Exiting moveToStartingPositionForCeilingFloor()");
end;

local function wallColumn(currentDirection, height)
    log (fine, "Entering wallColumn()");
    local height = height or 5;
    height = height - 2;
    local currentDirection = currentDirection;
    local initialFillSlot;
    local middleFillSlot = wallFiller1Pos;
    local endingFillSlot;

    if currentDirection == up then
        initialFillSlot = floorFillerPos;
        endingFillSlot = roofFillerPos;
    end
    if currentDirection == down then
        initialFillSlot = roofFillerPos;
        endingFillSlot = floorFillerPos;
    end

    moveWithDig(currentDirection, 2);
    replace(getOppositeDirection(currentDirection), initialFillSlot);
    for i = 1,height do
        moveWithDig(currentDirection, 1);
        replace(getOppositeDirection(currentDirection), middleFillSlot);
    end
    moveWithDig(currentDirection, 1);
    replace(getOppositeDirection(currentDirection), endingFillSlot);

    log (fine, "Exiting wallColumn()");
    return currentDirection;
end

local function buildWalls(startingUpDownDirection, numberColumns)
    log (fine, "Entering buildWalls()");
    local currentDirection = getOppositeDirection(startingUpDownDirection);
    local numberColumns = numberColumns;
    local numberWalls = 4;

    for x=1,numberWalls do
        for i=1,numberColumns do
            currentDirection = wallColumn(getOppositeDirection(currentDirection));
            log(debug, "i="..i.." numberColumns="..numberColumns);
            if (i < numberColumns) then
                moveWithDig(forward);
            end;
        end;
        if (x < numberWalls) then
            turn(left);
            moveWithDig(forward);
        end;
    end;
    log (fine, "Exiting buildWalls()");
    return currentDirection;
end;

local function moveToStartingPositionForWalls()
    log (fine, "Entering moveToStartingPositionForWalls()");
    local currentDirection = up;
    -- turtle should start at z=13 or higher
    -- this moves turtle from starting position to corner of room where the room anchor column will be built
    moveWithDig(down, 6);
    turn(left);
    moveWithDig(forward, 5);
    turn(right);
    moveWithDig(forward, 4);
    log (fine, "Exiting moveToStartingPositionForWalls()");
    return currentDirection;
end

--local currentDirection = moveToStartingPositionForWalls();
--currentDirection = buildWalls(currentDirection, 11);
moveToStartingPositionForCeilingFloor(left);
buildFloorAndCeiling(right, down, 3);
