function testCode()
    --floorAndCeilingBlock(up);
    floorAndCeilingRow();
end

-- Must allow for 1 available block above ceiling and 1 available block below floor

wallFiller1Pos = 1;
wallFiller2Pos = 2;
wallFiller3Pos = 3;
floorFillerPos = 4;
roofFillerPos = 5;
skylightFillerPos = 6;

up = "up";
down = "down";
forward = "forward";
right = "right";
left = "left";
back = "back";

function transitionOverAnd180Degrees(turnDirection, steps)
    steps = steps or 1;
    if (turnDirection == left) then turtle.turnLeft() end;
    if (turnDirection == right) then turtle.turnRight() end;
    move(forward, steps);
    if (turnDirection == left) then turtle.turnLeft() end;
    if (turnDirection == right) then turtle.turnRight() end;
end


-- look in slots 1-12 if selected slot if empty
function select(slot)
    turtle.select(slot)
    if turtle.getItemCount(slot) == 1 then
        turtle.select(1)
        while not turtle.compareTo(slot) do
            for i = 1, 12 do
                turtle.select(i)
            end
        end
    end
end

-- dig if can't move
function move(direction, steps, attempts)
    steps = steps or 1
    attempts = attempts or 10
    for i = 1, steps do
        local tries = 1
        while (((attempts == 0) or (tries <= attempts))) do
            if direction == up then
                if turtle.up() then
                    break;
                else
                    turtle.digUp()
                end
            end
            if direction == down then
                if turtle.down() then
                    break;
                else
                    turtle.digDown()
                end
            end
            if direction == forward then
                if turtle.forward() then
                    break;
                else
                    turtle.dig()
                end
            end
            -- THIS CONSTRUCTION IS USED SO TRIES WON'T OVERFLOW WHEN ATTEMPTS==0
            tries = math.min(tries + 1, attempts + 1)
            sleep(0)
        end
    end
end

-- Move if requested and if it can dig
function dig(direction, steps, attempts)
    steps = steps or 0
    attempts = attempts or 10
    repeat
        local tries = 1
        while (((attempts == 0) or (tries <= attempts))) do
            if direction == up then
                turtle.digUp();
                if steps > 0 and turtle.up() then break end;
            end

            if direction == down then
                turtle.digDown();
                if steps > 0 and turtle.down() then break end;
            end

            if direction == forward then
                turtle.dig();
                if steps > 0 and turtle.forward() then break end;
            end

            -- THIS CONSTRUCTION IS USED SO TRIES WON'T OVERFLOW WHEN ATTEMPTS==0
            tries = math.min(tries + 1, attempts + 1);
            sleep(0);
        end
        steps = steps - 1;
        until steps <= 0;
end

-- move if can't replace.
function replace(direction, slot, attempts)
    local moveBackCounter = 0;
    attempts = attempts or 10
    local tries = 1
    select(slot);

    if direction == up then
        while (((attempts==0) or (tries<=attempts)) and not turtle.placeUp()) do
            if turtle.detectUp() then
                turtle.digUp();
            else
                turtle.up();
                moveBackCounter = moveBackCounter + 1;
            end
            -- THIS CONSTRUCTION IS USED SO TRIES WON'T OVERFLOW WHEN ATTEMPTS==0
            tries = math.min(tries+1, attempts+1);
            sleep(0);
        end
        for i = 1,moveBackCounter do
            turtle.down();
        end
    end
    if direction == down then
        while (((attempts==0) or (tries<=attempts)) and not turtle.placeDown()) do
            if turtle.detectDown() then
                turtle.digDown();
            else
                turtle.down();
                moveBackCounter = moveBackCounter + 1;
            end
            -- THIS CONSTRUCTION IS USED SO TRIES WON'T OVERFLOW WHEN ATTEMPTS==0
            tries = math.min(tries+1, attempts+1);
            sleep(0);
        end
        for i = 1,moveBackCounter do
            turtle.up();
        end
    end
    if direction == forward then
        while (((attempts==0) or (tries<=attempts)) and not turtle.place()) do
            if turtle.detect() then
                turtle.dig();
            else
                turtle.forward();
                moveBackCounter = moveBackCounter + 1;
            end
            -- THIS CONSTRUCTION IS USED SO TRIES WON'T OVERFLOW WHEN ATTEMPTS==0
            tries = math.min(tries+1, attempts+1);
            sleep(0);
        end
        for i = 1,moveBackCounter do
            turtle.back();
        end
    end
end

function singleLine(moveDirection, height)
    local middleFillSlot = wallFiller1Pos;
    height = height or 2; -- 2 = actual height minus 1 for floor and minus 1 for the ceiling
    if moveDirection == up then
        placeDirection = down
        firstFillSlot = floorFillerPos;
        lastFillSlot = roofFillerPos;
    end
    if moveDirection == down then
        placeDirection = up;
        firstFillSlot = roofFillerPos;
        lastFillSlot = floorFillerPos;
    end

    move(moveDirection, 1);
    replace(placeDirection, firstFillSlot);
    for i = 1,height do
        move(moveDirection, 1);
        replace(placeDirection, middleFillSlot);
    end
    move(moveDirection, 1);
    replace(placeDirection, lastFillSlot);
end

function doubleLine(moveDirection, height)
    local middleFillSlot = wallFiller1Pos;
    height = height or 2; -- 2 = actual height minus 1 for floor and minus 1 for the ceiling
    if moveDirection == up then
        placeDirection = down
        firstFillSlot = floorFillerPos;
        lastFillSlot = roofFillerPos;
    end
    if moveDirection == down then
        placeDirection = up;
        firstFillSlot = roofFillerPos;
        lastFillSlot = floorFillerPos;
    end

    replace(forward, firstFillSlot);
    move(moveDirection, 1);
    replace(placeDirection, firstFillSlot);
    for i = 1,height do
        replace(forward, middleFillSlot);
        move(moveDirection, 1);
        replace(placeDirection, middleFillSlot);
    end
    replace(forward, lastFillSlot);
    move(moveDirection, 1);
    replace(placeDirection, lastFillSlot);
end

function lineTransition(numberOfLinesToJump, moveDirection)
    turtle.turnRight();
    turtle.turnRight();
    move(forward, numberOfLinesToJump);
    turtle.turnLeft();
    turtle.turnLeft();
    move(moveDirection, 1);
end

function floorAndCeilingColumn(moveDirection, columnHeight)
    columnHeight = columnHeight or 5;
    if moveDirection == up then
        firstPlaceDirection = down;
        lastPlaceDirection = up;
        firstFillSlot = floorFillerPos;
        lastFillSlot = roofFillerPos;
    end
    if moveDirection == down then
        firstPlaceDirection = up;
        lastPlaceDirection = down;
        firstFillSlot = roofFillerPos;
        lastFillSlot = floorFillerPos;
    end

    replace(firstPlaceDirection, firstFillSlot);
    move(moveDirection, columnHeight-4);
    replace(lastPlaceDirection, lastFillSlot);
end

-- Starting 'up'
function floorAndCeilingRow(rowLength)
    rowLength = rowLength or 9;
    rowLength = rowLength/2;
    for i = 1,rowLength do
        print ("1) i="..i.." and rowLength="..rowLength);
        floorAndCeilingColumn(down);
        if (i >= rowLength and not rowLength%2==0) then break end;  -- get in that last column on an odd numbered length
        print ("2) i="..i.." and rowLength="..rowLength);
        move(forward, 1);
        floorAndCeilingColumn(up);
        if (i < rowLength) then move(forward, 1) end;   -- reached the end, so don't transition to next column
        print ("3) i="..i.." and rowLength="..rowLength);
    end
end

function buildFloorAndCeiling(numberRows)
    numberRows = numberRows or 9;
    numberRows = numberRows/2;
    for i = 1,numberRows do
        floorAndCeilingRow();
        transitionOverAnd180Degrees(right);
        floorAndCeilingRow();
        transitionOverAnd180Degrees(left);
    end
end

function moveToStartingPosition()
    -- turtle should start at z=13 or higher
    -- this moves turtle from starting position to corner of room where the room anchor column will be built
    move(down, 6);
    turtle.turnLeft();
    move(forward, 5);
    turtle.turnRight();
    move(forward, 4);
    move(up, 1);
end

function buildWalls()
    singleLine(up);
    for i = 1,3 do
        if i%2==0 then
            direction1 = up;
            direction2 = down;
        else
            direction1 = down;
            direction2 = up;
        end

        lineTransition(2, direction1);
        doubleLine(direction1);
        lineTransition(2, direction2);
        doubleLine(direction2);
        lineTransition(2, direction1);
        doubleLine(direction1);
        lineTransition(2, direction2);
        doubleLine(direction2);
        lineTransition(2, direction1);
        doubleLine(direction1);
        turtle.turnLeft();
    end

    lineTransition(2, up);
    doubleLine(up);
    lineTransition(2, down);
    doubleLine(down);
    lineTransition(2, up);
    doubleLine(up);
    lineTransition(2, down);
    doubleLine(down);
    lineTransition(1, up);
    singleLine(up);

    -- Get into position to build the ceiling/floor
    turtle.turnLeft();
    move(forward);
    move(down, 2);
    turtle.turnLeft();
end

testCode();