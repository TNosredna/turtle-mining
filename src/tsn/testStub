upTick = 0;
downTick = 1;
leftTick = 0;
rightTick = 1;
forwardTick = 0;
backTick = 1;

function testCode()
    floorAndCeilingRow(downTick);
end

-- Must allow for 1 available block above ceiling and 1 available block below floor

wallFiller1Pos = 1;
wallFiller2Pos = 2;
wallFiller3Pos = 3;
floorFillerPos = 4;
roofFillerPos = 5;
skylightFillerPos = 6;

up = "up";
down = "down";
forward = "forward";
right = "right";
left = "left";
back = "back";

function transitionOverAnd180Degrees(turnDirection, steps)
    steps = steps or 1;
    if (turnDirection == left) then turtle.turnLeft() end;
    if (turnDirection == right) then turtle.turnRight() end;
    move(forward, steps);
    if (turnDirection == left) then turtle.turnLeft() end;
    if (turnDirection == right) then turtle.turnRight() end;
end

-- look in slots 1-12 if selected slot if empty
function select(slot)
    turtle.select(slot)
    if turtle.getItemCount(slot) == 1 then
        turtle.select(1)
        while not turtle.compareTo(slot) do
            for i = 1, 12 do
                turtle.select(i)
            end
        end
    end
end

-- dig if can't move
function move(direction, steps, attempts)
    steps = steps or 1
    attempts = attempts or 10
    for i = 1, steps do
        local tries = 1
        while (((attempts == 0) or (tries <= attempts))) do
            if direction == up then
                if turtle.up() then
                    break;
                else
                    turtle.digUp()
                end
            end
            if direction == down then
                if turtle.down() then
                    break;
                else
                    turtle.digDown()
                end
            end
            if direction == forward then
                if turtle.forward() then
                    break;
                else
                    turtle.dig()
                end
            end
            -- THIS CONSTRUCTION IS USED SO TRIES WON'T OVERFLOW WHEN ATTEMPTS==0
            tries = math.min(tries + 1, attempts + 1)
            sleep(0)
        end
    end
end

-- Move if requested and if it can dig
function dig(direction, steps, attempts)
    steps = steps or 0
    attempts = attempts or 10
    repeat
        local tries = 1
        while (((attempts == 0) or (tries <= attempts))) do
            if direction == up then
                turtle.digUp();
                if steps > 0 and turtle.up() then break end;
            end

            if direction == down then
                turtle.digDown();
                if steps > 0 and turtle.down() then break end;
            end

            if direction == forward then
                turtle.dig();
                if steps > 0 and turtle.forward() then break end;
            end

            -- THIS CONSTRUCTION IS USED SO TRIES WON'T OVERFLOW WHEN ATTEMPTS==0
            tries = math.min(tries + 1, attempts + 1);
            sleep(0);
        end
        steps = steps - 1;
        until steps <= 0;
end

-- move if can't replace.
function replace(direction, slot, attempts)
    local moveBackCounter = 0;
    attempts = attempts or 10
    local tries = 1
    select(slot);

    if direction == up then
        while (((attempts==0) or (tries<=attempts)) and not turtle.placeUp()) do
            if turtle.detectUp() then
                turtle.digUp();
            else
                turtle.up();
                moveBackCounter = moveBackCounter + 1;
            end
            -- THIS CONSTRUCTION IS USED SO TRIES WON'T OVERFLOW WHEN ATTEMPTS==0
            tries = math.min(tries+1, attempts+1);
            sleep(0);
        end
        for i = 1,moveBackCounter do
            turtle.down();
        end
    end
    if direction == down then
        while (((attempts==0) or (tries<=attempts)) and not turtle.placeDown()) do
            if turtle.detectDown() then
                turtle.digDown();
            else
                turtle.down();
                moveBackCounter = moveBackCounter + 1;
            end
            -- THIS CONSTRUCTION IS USED SO TRIES WON'T OVERFLOW WHEN ATTEMPTS==0
            tries = math.min(tries+1, attempts+1);
            sleep(0);
        end
        for i = 1,moveBackCounter do
            turtle.up();
        end
    end
    if direction == forward then
        while (((attempts==0) or (tries<=attempts)) and not turtle.place()) do
            if turtle.detect() then
                turtle.dig();
            else
                turtle.forward();
                moveBackCounter = moveBackCounter + 1;
            end
            -- THIS CONSTRUCTION IS USED SO TRIES WON'T OVERFLOW WHEN ATTEMPTS==0
            tries = math.min(tries+1, attempts+1);
            sleep(0);
        end
        for i = 1,moveBackCounter do
            turtle.back();
        end
    end
end

function singleLine(moveDirection, height)
    local middleFillSlot = wallFiller1Pos;
    height = height or 2; -- 2 = actual height minus 1 for floor and minus 1 for the ceiling
    if moveDirection == up then
        placeDirection = down
        firstFillSlot = floorFillerPos;
        lastFillSlot = roofFillerPos;
    end
    if moveDirection == down then
        placeDirection = up;
        firstFillSlot = roofFillerPos;
        lastFillSlot = floorFillerPos;
    end

    move(moveDirection, 1);
    replace(placeDirection, firstFillSlot);
    for i = 1,height do
        move(moveDirection, 1);
        replace(placeDirection, middleFillSlot);
    end
    move(moveDirection, 1);
    replace(placeDirection, lastFillSlot);
end

function doubleLine(moveDirection, height)
    local middleFillSlot = wallFiller1Pos;
    height = height or 2; -- 2 = actual height minus 1 for floor and minus 1 for the ceiling
    if moveDirection == up then
        placeDirection = down
        firstFillSlot = floorFillerPos;
        lastFillSlot = roofFillerPos;
    end
    if moveDirection == down then
        placeDirection = up;
        firstFillSlot = roofFillerPos;
        lastFillSlot = floorFillerPos;
    end

    replace(forward, firstFillSlot);
    move(moveDirection, 1);
    replace(placeDirection, firstFillSlot);
    for i = 1,height do
        replace(forward, middleFillSlot);
        move(moveDirection, 1);
        replace(placeDirection, middleFillSlot);
    end
    replace(forward, lastFillSlot);
    move(moveDirection, 1);
    replace(placeDirection, lastFillSlot);
end

function lineTransition(numberOfLinesToJump, moveDirection)
    turtle.turnRight();
    turtle.turnRight();
    move(forward, numberOfLinesToJump);
    turtle.turnLeft();
    turtle.turnLeft();
    move(moveDirection, 1);
end

function floorAndCeilingColumn(currentDirection, numberBlocks)
    numberBlocks = numberBlocks or 5;
    if currentDirection == up then
        initialPlaceDirection = down;
        endingPlaceDirection = up;
        initialFillSlot = floorFillerPos;
        endingFillSlot = roofFillerPos;
    end
    if currentDirection == down then
        initialPlaceDirection = up;
        endingPlaceDirection = down;
        initialFillSlot = roofFillerPos;
        lastFillSlot = floorFillerPos;
    end

    replace(initialPlaceDirection, initialFillSlot);
    move(currentDirection, numberBlocks -4);
    replace(endingPlaceDirection, endingFillSlot);
end

function floorAndCeilingRow(currentDirectionTick, numberColumns)
    numberColumns = numberColumns or 9;

    for i = 1,numberColumns do
        if (currentDirectionTick%2 == 0) then
            floorAndCeilingColumn(up);
        else
            floorAndCeilingColumn(down);
        end;
        currentDirectionTick = currentDirectionTick + 1;

        if (i < numberColumns) then
            move(forward, 1)
        end;
    end
end

function buildFloorAndCeiling(currentLeftRightDirectionTick, currentUpDownDirectionTick, numberRows)
    numberRows = numberRows or 9;

    for i = 1,numberRows do
        floorAndCeilingRow(currentUpDownDirectionTick, numberRows);
        currentUpDownDirectionTick = currentUpDownDirectionTick + 1;
        if (i < numberRows) then
            if (currentLeftRightDirectionTick%2 == 0) then
                transitionOverAnd180Degrees(left);
            else
                transitionOverAnd180Degrees(right);
            end;
            currentLeftRightDirectionTick = currentLeftRightDirectionTick + 1;
        end;
    end
end

function moveToStartingPosition()
    -- turtle should start at z=13 or higher
    -- this moves turtle from starting position to corner of room where the room anchor column will be built
    move(down, 6);
    turtle.turnLeft();
    move(forward, 5);
    turtle.turnRight();
    move(forward, 4);
    move(up, 1);
end

function buildWalls()
    singleLine(up);
    for i = 1,4 do
        if i%2==0 then
            direction1 = up;
            direction2 = down;
        else
            direction1 = down;
            direction2 = up;
        end

        lineTransition(2, direction1);
        doubleLine(direction1);
        lineTransition(2, direction2);
        doubleLine(direction2);
        lineTransition(2, direction1);
        doubleLine(direction1);
        lineTransition(2, direction2);
        doubleLine(direction2);
        if (i<4) then
            lineTransition(2, direction1);
            doubleLine(direction1);
        else
            lineTransition(1, direction1);
            singleLine(direction1);
        end;
        turtle.turnLeft();
    end

    -- Get into position to build the ceiling/floor
    turtle.turnLeft();
    move(forward);
    move(down, 2);
    turtle.turnLeft();
end

testCode();
-- moveToStartingPosition();
-- buildWalls();
-- buildFloorAndCeiling();
