-- Must allow for 1 available block above ceiling and 1 available block below floor

-- Slot Assignments
local wallFiller1Slot = 1;     -- digStation (64)
local wallFiller2Slot = 2;     -- digStation (64)
local wallFiller3Slot = 3;     -- digStation (32)
local wallFiller4Slot = 4;     -- digShaft (64)
local floorFillerSlot = 5;     -- digStation (49)
local roofFillerSlot = 6;      -- digStation (49)
local stonePipe1Slot = 7;       -- prepareShaft (64)
local stonePipe2Slot = 8;       -- prepareStation (2-8)
local redWireSlot = 9;         -- prepareShaft (64)
local smallChestSlot = 10;     -- prepareStation (4-16) / prepareShaft (2)
local redstoneEngineSlot = 11; -- prepareStation (1-4) / prepareShaft (1)
local woodenPipeSlot = 12;     -- prepareStation (1-4) / prepareShaft (1)
local redstoneTorchSlot = 13;  -- prepareStation (1-4) / prepareShaft (1)
local torchSlot = 14;          -- prepareStation (10) / prepareShaft (11)
local ladderSlot = 15;         -- digShaft (64)
local fuelSlot = 16;           -- digShaft

local up = "up";
local down = "down";
local forward = "forward";
local right = "right";
local left = "left";
local back = "back";

local error = 0;
local coarse = 1;
local fine = 2;
local debug = 3;
local currentLogLevel = debug;

local currentSlotNum = 1;

local success = true;
local failure = false;

local blockPlaced = 0;
local blockAlreadyPresent = 1;
local notEnoughInventory = 2;
local noAnchorBlocks = 3;

local currentLogIndent = 0;
local logFileName = os.computerID()..".log";
local darkness = 0;

os.loadAPI("turtleUtils");

local args={...};
local radius = args[1] or 5;
local height = args[2] or 5;

local function floorAndCeilingColumn(currentUpDownDirection, numberBlocks)
    turtleUtils.log(fine, "Entering floorAndCeilingColumn()");
    currentLogIndent = currentLogIndent + 1;
    local numberBlocks = numberBlocks or 5;
    local currentUpDownDirection = currentUpDownDirection;
    local initialFillSlot;
    local endingFillSlot;

    if currentUpDownDirection == up then
        initialFillSlot = floorFillerSlot;
        endingFillSlot = roofFillerSlot;
    else
        initialFillSlot = roofFillerSlot;
        endingFillSlot = floorFillerSlot;
    end

    turtleUtils.replace(getOppositeDirection(currentUpDownDirection), initialFillSlot);
    turtleUtils.moveWithDig(currentUpDownDirection, numberBlocks-4);
    turtleUtils.replace(currentUpDownDirection, endingFillSlot);

    currentLogIndent = currentLogIndent - 1;
    turtleUtils.log (fine, "Exiting floorAndCeilingColumn()");
    return currentUpDownDirection;
end

local function floorAndCeilingRow(currentDirection, numberColumns, height)
    turtleUtils.log (fine, "Entering floorAndCeilingRow()");
    currentLogIndent = currentLogIndent + 1;
    local numberColumns = numberColumns or 9;
    local height = height or 5;
    local currentDirection = currentDirection;

    for i = 1,numberColumns do
        currentDirection = floorAndCeilingColumn(getOppositeDirection(currentDirection), height);
        if (i < numberColumns) then
            turtleUtils.moveWithDig(forward, 1)
        end
    end
    currentLogIndent = currentLogIndent - 1;
    turtleUtils.log (fine, "Exiting floorAndCeilingRow()");
    return currentDirection;
end

local function buildFloorAndCeiling(currentLeftRightDirection, currentUpDownDirection, numberRows, height)
    turtleUtils.log (fine, "Entering buildFloorAndCeiling()");
    currentLogIndent = currentLogIndent + 1;
    local numberRows = numberRows or 9;
    local numberColumns = numberRows;
    local hieght = height or 5;
    local currentUpDownDirection = currentUpDownDirection;
    local currentLeftRightDirection = currentLeftRightDirection;

    for i = 1,numberRows do
        currentUpDownDirection = floorAndCeilingRow(currentUpDownDirection, numberColumns, height);
        if (i < numberRows) then
            currentLeftRightDirection = turtleUtils.getOppositeDirection(currentLeftRightDirection);
            turtleUtils.transitionOverAnd180Degrees(currentLeftRightDirection);
        end
    end
    currentLogIndent = currentLogIndent - 1;
    turtleUtils.log (fine, "Exiting buildFloorAndCeiling()");
end

local function moveToStartingPositionForCeilingFloor(turnDirection)
    turtleUtils.log (fine, "Entering moveToStartingPositionForCeilingFloor()");
    currentLogIndent = currentLogIndent + 1;
    local turnDirection = turnDirection;
    turtleUtils.transitionOverAnd180Degrees(turnDirection);
    turtleUtils.moveWithDig(forward);
    turtleUtils.moveWithDig(up, 2);
    currentLogIndent = currentLogIndent - 1;
    turtleUtils.log (fine, "Exiting moveToStartingPositionForCeilingFloor()");
end;

local function wallColumn(currentDirection, height)
    turtleUtils.log (fine, "Entering wallColumn()");
    currentLogIndent = currentLogIndent + 1;
    local height = height or 5;
    height = height - 2;
    local currentDirection = currentDirection;
    local initialFillSlot;
    local middleFillSlot = wallFiller1Slot;
    local endingFillSlot;

    if currentDirection == up then
        initialFillSlot = floorFillerSlot;
        endingFillSlot = roofFillerSlot;
    end
    if currentDirection == down then
        initialFillSlot = roofFillerSlot;
        endingFillSlot = floorFillerSlot;
    end

    turtleUtils.moveWithDig(currentDirection, 2);
    turtleUtils.replace(getOppositeDirection(currentDirection), initialFillSlot);
    for i = 1,height do
        turtleUtils.moveWithDig(currentDirection, 1);
        turtleUtils.replace(getOppositeDirection(currentDirection), middleFillSlot);
    end
    turtleUtils.moveWithDig(currentDirection, 1);
    turtleUtils.replace(getOppositeDirection(currentDirection), endingFillSlot);

    currentLogIndent = currentLogIndent - 1;
    turtleUtils.log (fine, "Exiting wallColumn()");
    return currentDirection;
end

local function buildWalls(startingUpDownDirection, numberColumns, height)
    turtleUtils.log (fine, "Entering buildWalls()");
    currentLogIndent = currentLogIndent + 1;
    local currentDirection = turtleUtils.getOppositeDirection(startingUpDownDirection);
    local numberColumns = numberColumns - 1;     -- difficult to communicate this number. misleading -> 10 leaves 9 inner spaces
    local numberWalls = 4;

    for x=1,numberWalls do
        for i=1,numberColumns do
            currentDirection = wallColumn(getOppositeDirection(currentDirection), height);
            if (i < numberColumns) then
                turtleUtils.moveWithDig(forward);
            end;
        end;
        if (x < numberWalls) then
            turtleUtils.turn(left);
            turtleUtils.moveWithDig(forward);
        end;
    end;
    currentLogIndent = currentLogIndent - 1;
    turtleUtils.log (fine, "Exiting buildWalls()");
    return currentDirection;
end;

local function moveToStartingPositionForWalls(radius, height)
    turtleUtils.log (fine, "Entering moveToStartingPositionForWalls()");
    currentLogIndent = currentLogIndent + 1;
    local currentDirection = up;
    -- turtle should start at z=13 or higher
    -- this moves turtle from starting position to corner of room where the room anchor column will be built
    turtleUtils.moveWithDig(down, height + 1);
    turtleUtils.moveWithDig(forward, radius + 1);
    turtleUtils.turn(right);
    turtleUtils.moveWithDig(forward, radius);
    turtleUtils.turn(right);
    currentLogIndent = currentLogIndent - 1;
    turtleUtils.log (fine, "Exiting moveToStartingPositionForWalls()");
    return currentDirection;
end

if ((radius == nil or radius=="") or (height == nil or height=="")) then
    fs.delete(logFileName);
    print ("What is the desired radius of the station? (5 is normal)");
    radius = io.read();
    radius = tonumber(radius);

    print ("What is the desired height, including floor and ceiling layers, of the station? (5 is normal)");
    height = io.read();
    height = tonumber(height);
end;

local diameter = radius * 2;
local currentDirection = moveToStartingPositionForWalls(radius, height);
currentDirection = buildWalls(currentDirection, (diameter +1), height);
moveToStartingPositionForCeilingFloor(left);
buildFloorAndCeiling(left, down, (diameter - 1), height);
